---
title: "การทำโมเดลและนำเสนอข้อมูล"
editor: visual
---

```{r include=FALSE}
pacman::p_load(
	shiny,
	htmltools,
	bs4Dash,
	fresh,
	waiter,
	shinyWidgets,
	Guerry,
	sf,
	tidyr,
	dplyr,
	RColorBrewer,
	viridis,
	leaflet,
	plotly,
	jsonlite
)

variable_names <- list(
  Crime_pers = "Crime against persons",  
  Crime_prop =  "Crime against property",  
  Literacy = "Literacy",  
  Donations = "Donations to the poor",  
  Infants = "Illegitimate births",  
  Suicides = "Suicides",  
  Wealth = "Tax / capita",  
  Commerce = "Commerce & Industry",  
  Clergy = "Clergy",  
  Crime_parents = "Crime against parents",  
  Infanticide = "Infanticides",  
  Donation_clergy = "Donations to the clergy",  
  Lottery = "Wager on Royal Lottery",  
  Desertion = "Military desertion",  
  Instruction = "Instruction",  
  Prostitutes = "Prostitutes",  
  Distance = "Distance to paris",  
  Area = "Area",  
  Pop1831 = "Population"
)

data_guerry <- Guerry::gfrance85 %>%
  st_as_sf() %>%
  as_tibble() %>%
  st_as_sf(crs = 27572) %>%
  mutate(Region = case_match(
    Region,
    "C" ~ "Central",
    "E" ~ "East",
    "N" ~ "North",
    "S" ~ "South",
    "W" ~ "West"
  )) %>%
  select(-c("COUNT", "dept", "AVE_ID_GEO", "CODE_DEPT")) %>%
  select(Region:Department, all_of(names(variable_names)))
```

ในหัวข้อนี้เราจะเรียนรู้:

-   การใส่พวกกราฟและไดอะแกรมต่างจาก ggplo2 ใน Shiny
-   การทำกราฟแบบมี interactive ด้วย Plotly
-   การนำเสนอแบบ interactive ด้วย dashboards
-   นำเสนอผลลัพธ์จากการทำ regression ใน Shiny

# การนำเสนอแบบ Interactive: หัวใจสำคัญของ Shiny

-   Shiny มีสิ่งจำเป็นสำหรับการนำเสนอต่างๆ
    -   พวก Plots ต่างๆ สามารถปรับเปลี่ยนผ่าน UI inputs
    -   พวกปฏิสัมพันธ์กับกราฟอย่าง การซูมเข้า/ออกก็มีให้เรียบร้อย
    -   พวก Dashboards ก็ช่วยเหลือการทำความเข้าใจหรือการเปรียบได้ดี 

## ตัวอย่าง 

-   ตัวอย่าง app เกี่ยวกับเรื่อง COVID-19 ของ Edward Parker [COVID-19 tracker](https://vac-lshtm.shinyapps.io/ncov_tracker/)

::: callout-note
## Exercise

ให้ทดลองเล่น app COVID-19 tracker คืดว่า app นี้เป็นตัวอย่างที่ดีหรือไม่ เพราะอะไร
:::

![COVID-19 Tracker](https://raw.githubusercontent.com/eparker12/nCoV_tracker/master/www/app_image.png)

## สถานะของ app 

-   ในหัวข้อนี้เราจะค่อย ๆ ปรับปรุง app ของเรากัน
-   code ด้านล่างนี้คือ app ที่เรามี มันจะมีตัวอย่างการใช้ table tabs
-   ทบทวน:
    -   ในหัวข้อที่ 3 เราใส่ tab ที่มีคำอธิบาย app
    -   ในหัวข้อที่ 4 เราเพิ่ม table tab โดยใช้ `DT` package
    -   ในหัวข้อนี้เราจะเพิ่ม tab ที่เกี่ยวกับการวิเคราะห์ข้อมูลของ Guerry 

```{r eval=FALSE, file="shinyapps/guerry/states/05_visualization00.R"}
#| code-fold: true
#| code-summary: Full code for the current app state
```

## แหล่งข้อมูลเพิ่มเติม

-   [Chapter "Graphics"](https://mastering-shiny.org/action-graphics.html) Hadley Wickham's Mastering Shiny
-   ["Server-side linking with shiny"](https://plotly-r.com/linking-views-with-shiny.html) หนังสือ Plotly ของ Carson Sievert

# การ Plot ใน Shiny

-   การใส่พวกกราฟหรือplot ก็เหมือนกับใส่องค์ประกอบตัวควบคุมอื่นใน UI 
-   เราต้องการเพียงคำสั่ง: `plotOutput()` ใน UI กับ `renderPlot()` ในส่วนของ server
    -   [`plotOutput()`](https://shiny.posit.co/r/reference/shiny/1.7.4/plotoutput) สร้างที่บน UI สำหรับใส่กราฟ
    -   [`renderPlot()`](https://shiny.posit.co/r/reference/shiny/1.7.4/renderplot )สร้างกราฟแล้วเอาไปใส่ที่ที่เตรียมไว้บน UI

## เพิ่ม section ใหม่ใน Guerry app

-   เพิ่ม tab ใหม่ใน app และเรียกมันว่า "Model data"
-   จุดประสงค์เพื่อดูความสัมพันธ์ของตัวแปรต่างๆ 
-   **คำถาม**: ถ้าเราจะดูเรื่องความสัมพันธ์ระหว่างตัวแปร ความจะนำเสนอในรูปแบบอะไร

## ใส่ส่วนประกอบใน UI 

-   ลองดูที่ code ว่าเราใส่ tab เพิ่มอย่างไร:

```{r eval=F}
model <- tabItem(              # <1>
	"tab_model",                     # <1>
	fluidRow(                    # <2>
		column(                    # <2>
			width = 6,               # <2>
	    box(                     # <2>
				width = 12,            # <2>
				title = "Pair diagram",# <2>
				status = "primary",    # <2>
				plotOutput("pairplot") # <3>
			)
		)
	)
)
```

1.  สร้าง tab item เรียก "tab_model"
2.  สร้างรูปแบบ layout เริ่มต้นที่ใช้ fluid row กับ 1 column และ 1 กล่อง box
3.  ใส่ที่สำหรับกราฟ 

-   tab Item ที่ใส่ใหม่ชื่อ `tab_model`
-   เรามี tabs item อยู่แล้วที่ชื่อ `tab_intro` กับ `tab_tabulate`:

```{r eval=FALSE}
dashboardPage(
  header = dashboardHeader(
    title = tagList(
      img(src = "workshop-logo.png", width = 35, height = 35),
      span("The Guerry Dashboard", class = "brand-text")
    )
  ),
  sidebar = dashboardSidebar(                             # <1>
    id = "sidebar",                                       # <1>
    sidebarMenu(                                          # <1>
      id = "sidebarMenu",                                 # <1>
      menuItem(tabName = "tab_intro", text = "Introduction", icon = icon("home")), # <1>
      menuItem(tabName = "tab_tabulate", text = "Tabulate data", icon = icon("table")), # <1>
      menuItem(tabName = "tab_model", text = "Model data", icon = "chart-line")    # <1>
    )
  ),
  body = dashboardBody(                                   # <2>
    # Note: Tab contents omitted to maintain readability!
    tabItems(                                             # <2>
      tabItem(tabName = "tab_intro"),                         # <2>
      tabItem(tabname = "tab_tabulate"),
      model                                               # <2>
    )
  )
)
```

1.  ใส่ menu items ที่ sidebar อย่าลืมใส่ชื่อให้ตรงกับ tab
2.  ใส่ tab items ในตัว body  ซึ่ง`tabItems()` จะมีตัวรวบรวมtabทั้งหมด  ตัว `tab_model` ใส่ต่อจากintroduction และชื่อของ`tabItem()`ต้องตรงตามลำดับกับชื่อใน `menuItem()`

## ใส่เนื้อหา

-   ใส่อะไรก็ได้ที่อยากใส่
-   เราใส่พวกทำ plotting ต่าง ๆที่ server 
-   ในที่นี้เราใช้ [`ggpairs`](https://ggobi.github.io/ggally/reference/ggpairs.html) จาก [`GGally`](https://ggobi.github.io/ggally/) package จริงๆ จะใช้อะไรก็ได้ที่เกี่ยวข้องกับการทำกราฟ

```{r eval=F}
output$pairplot <- renderPlot({                             # <1>
	dt <- st_drop_geometry(guerry[c("Literacy", "Commerce")]) # <2>
	GGally::ggpairs(dt, axisLabels = "none")                  # <3>
})
```

1.  `renderPlot()` จะรับชุดคำสั่งที่มีการสร้างกราฟ
2.  เตรียมข้อมูลให้พร้อมสำหรับการplot
3.  `ggpairs()` เป็นคำสั่งสำหรับสร้างกราฟอันหนึ่งจาก ggplot2 
![](resources/05_01.png)

## code ตัวเต็ม

```{r eval=FALSE, file="shinyapps/guerry/states/05_visualization01.R"}
#| code-fold: true
#| code-summary: Full code for basic plotting
```

## ข้อจำกัด

-   code ที่ใช้ในการplotนี้เป็นแบบอย่างง่าย ที่ดูไม่ค่อยจะต่างจากคำสั่งplot ต่างๆที่มาด้วยกับ R
-   ถ้าอยากเห็นที่มันแตกต่าง ต้องดูในคุณสมบัติทั้ง 3 นี้:
    -   Reactivity ปฏิกิริยา
    -   Interactivity โต้ดอบ
    -   Contextuality บริบท

# Reactivity ปฏิกิริยา

-   Reactivity หมายถึงเพิ่มตัวที่ขึ้นกับ reactive นั้นๆ
-   ในที่นี้เราพิมพ์ใส่ชื่อตัวแปรลงไป แต่ผู้ใช้ก็สามารถที่จะเลือกได้

## การใส่ input ต่าง ๆ ใน UI

-   ตอนนี้เราใช้ Inputsอยู่ 3 แบบ
    -   [`selectInput()`](https://shiny.posit.co/r/reference/shiny/1.7.4/selectinput) เพื่อเลือกตัวแปร x (ค่าเริ่มต้นคือ Literacy)
    -   [`selectizeInput()`](https://shiny.posit.co/r/reference/shiny/1.7.4/selectinput) เพื่อเลือกตัวแปร y (ค่าเริ่มต้นคือ Commerce)
    -   [`checkboxInput()`](https://shiny.posit.co/r/reference/shiny/1.7.4/checkboxinput) เพื่อเป็นทางเลือกว่าจะทำ standardize หรือไม่

::: callout-note
เราใส่ปุ่ม [`actionButton()`](https://shiny.posit.co/r/reference/shiny/1.7.4/actionbutton) เพื่อให้ผู้ใช้กดเพื่อดูผลหลังจากเหลือ Inputs ต่างๆ 
:::

```{r eval=F}
model <- tabItem(
	"tab_model",
	fluidRow(                                                             # <1>
		column(                                                             # <1>
			width = 6,                                                        # <1>
			#### Box: Select variables ----
      box(                                                              # <1>
				width = 12,                                                     # <1>
				title = "Select variables",                                     # <1>
				status = "primary",                                             # <1>
				selectInput(                                                    # <2>
					"model_x",                                                    # <2>
					label = "Select a dependent variable",                        # <2>
					choices = setNames(names(variable_names), variable_names),   # <2>
					selected = "Literacy"                                         # <2>
				),                                                              # <2>
				selectizeInput(                                                 # <3>
					"model_y",                                                    # <3>
					label = "Select independent variables",                       # <3>
					choices = setNames(names(variable_names), variable_names),   # <3>
					multiple = TRUE,                                              # <3>
					selected = "Commerce"                                         # <3>
				),                                                              # <3>
				checkboxInput(                                                  # <4>
					"model_std",                                                  # <4>
					label = "Standardize variables?",                             # <4>
					value = TRUE                                                  # <4>
				),                                                              # <4>
				hr(),
				actionButton(                                                   # <5>
					"refresh",                                                    # <5>
					label = "Apply changes",                                      # <5>
					icon = icon("refresh"),                                       # <5>
					flat = TRUE                                                   # <5>
				)                                                               # <5>
			)
		),
		#### Box: Pair diagramm ----
		column(
			width = 6,
	    box(
				width = 12,
				title = "Pair diagram",
				status = "primary",
				plotOutput("pairplot")
			)
		)
	)
)
```

1.  สร้าง column กับ box ใหม่สำหรับใส่ Inputs ต่างๆ
2.  สร้าง `selectInput()` สำหรับเลือกตัวแปร x  โดยใส่รายชื่อตัวแปรที่จะเลือกทั้งหมดใน `choices` 
3.  สร้าง `selectizeInput()` สำหรับเลือกตัวแปร y 
4.  ใส่ `checkboxInput()` ให้ผู้ใช้เลือกว่าจะ standardize ตัวแปรหรือไม่
5.  สร้างปุ่ม `actionButton()` เพื่อส่งให้ทำการคำนวณตามค่า Inputs ต่างๆที่เลือกไป

## การเข้าถึง UI inputs ที่ใส่เข้าไปใหม่

-   **คำถาม:** UI inputs อันไหนที่เราเพิ่งใส่เข้าไป แล้วเราจะเข้าถึงค่าของมันจากฝั่ง server ได้อย่างไร
-   เราใส่ตัว reactive ใหม่สำหรับ **clean** ข้อมูล

::: callout-note
[`bindEvent`](https://shiny.posit.co/r/reference/shiny/1.7.4/bindevent) เพื่อให้มั่นใจว่าจะคำนวณใหม่โดยใช้ค่า inputที่ใส่เข้ามาหลังจากกดปุ่ม `actionButton()` เท่านั้น  ลองเอาออก แล้วดูว่าเกิดอะไรขึ้น
:::

```{r eval=F}
dat <- reactive({                                           # <1>
	x <- input$model_x                                       # <1>
	y <- input$model_y                                       # <1>
	dt <- sf::st_drop_geometry(guerry)[c(x, y)]              # <1>
	if (input$model_std) dt <- datawizard::standardise(dt)   # <1>
	dt                                                       # <1>
}) %>%                                                     # <1>
	bindEvent(input$refresh, ignoreNULL = FALSE)             # <2>

output$pairplot <- renderPlot({
	GGally::ggpairs(dat(), axisLabels = "none")               # <3>
})
```

1.  สร้าง reactive expression ที่คอยดูเรื่อง cleaning และจัดเก็บข้อมูลในตัวแปร reactive object ชื่อ `dat`
2.  ซึ่ง reactive expression ที่อยู่ใน `reactive` จะถูกรันใหม่(หรืออัพเดทค่า `dat`) ก็ต่อเมื่อปุ่มrefresh ถูกกด
3.  สร้าง pairs plot โดยใช้ค่าจาก `dat()`  เช่นเดียวกันกับ `dt` dataframe ที่เราใช้ก่อนหน้านี้ เพียงแต่ว่า ตัว`dat()` จะมีการอัพเดทค่าทุกครั้งที่ค่าของ `input$model_x` `input$model_y` หรือ `input$model_std` มีการเปลี่ยนแปลง

![](resources/05_02.gif)

-   ตัวกราฟจะมีผลเปลี่ยนแปลงทันทีที่ผู้ใช้เลือกหรือเปลี่ยน Inputs

## code ตัวเต็ม

```{r eval=FALSE, file="shinyapps/guerry/states/05_visualization02.R"}
#| code-fold: true
#| code-summary: Full code for reactive plotting
```

# Interactivity โต้ตอบ

-   ตอนนี้ภาพกราของเรายังเป็นแบบนิ่ง ๆ 
-   กราฟแบบนิ่งๆนี้ก็เหมาะกับรายงานหรือบทความทั่วไป แต่ Shiny ได้มากกว่านั้น
-   คุณสมบัติของ Shiny พื้นฐานสำหรับ โต้ตอบก็มีอย่างเช่น คลิ๊ก ดับเบิ้ลคลิ๊ก วางค้างไว้ หรือ ลากคลุมเพื่อเลือก (ดูเพิ่มเติมที่ [Chapter 7.1](https://mastering-shiny.org/action-graphics.html#interactivity))
-   ในที่นี้เราจะลองใช้กราฟที่ทำจาก Plotly

## Plotly

-   [Plotly](https://plotly.com/) เป็นlibrary สำหรับสร้างกราฟที่มีการโต้ตอบกับผู้ใช้
-    Plotly สามารถใช้ได้กับหลายภาษา ซึ่งรวมถึง R และ Shiny ด้วย

```{r}
#| code-fold: true
#| code-summary: Code to re-produce the Plotly figure

mtcars$am[which(mtcars$am == 0)] <- 'Automatic'
mtcars$am[which(mtcars$am == 1)] <- 'Manual'
mtcars$am <- as.factor(mtcars$am)


plot_ly(
  mtcars,
  x = ~wt,
  y = ~hp,
  z = ~qsec,
  color = ~am,
  colors = c('#BF382A', '#0C4B8E')) %>%
  add_markers() %>%
  layout(scene = list(
    xaxis = list(title = 'Weight'),
    yaxis = list(title = 'Gross horsepower'),
    zaxis = list(title = '1/4 mile time')
  ))
```

## Plotly กับ Shiny

-   คำสั่งสำหรับการแสดงผลกราฟจาก Plotly ก็เหมือนกันกับก่อนหน้านี้:
    -   [`plotlyOutput()`](https://rdrr.io/cran/plotly/man/plotly-shiny.html) สำหรับสร้าง UI เพื่อแสดงผล
    -   [`renderPlotly()`](https://rdrr.io/cran/plotly/man/plotly-shiny.html) สำหรับสร้างกราฟเพื่อไปแสดงผลบน UI ที่เตรียมไว้

```{r eval=F}
model <- tabItem(
	"tab_model",
	fluidRow(
		column(
			width = 6,
			#### Box: Select variables ----
      box(
				width = 12,
				title = "Select variables",
				status = "primary",
				selectInput(
					"model_x",
					label = "Select a dependent variable",
					choices = setNames(names(variable_names), variable_names),
					selected = "Literacy"
				),
				selectizeInput(
					"model_y",
					label = "Select independent variables",
					choices = setNames(names(variable_names), variable_names),
					multiple = TRUE,
					selected = "Commerce"
				),
				checkboxInput(
					"model_std",
					label = "Standardize variables?",
					value = TRUE
				),
				hr(),
				actionButton(
					"refresh",
					label = "Apply changes",
					icon = icon("refresh"),
					flat = TRUE
				)
			)
		),
		#### Box: Pair diagramm ----
		column(
			width = 6,
	    box(
				width = 12,
				title = "Pair diagram",
				status = "primary",
				plotly::plotlyOutput("pairplot") # <1>
			)
		)
	)
)
```

1.  สิ่งที่เปลี่ยนเข้าไปคือการใช้ Plotly ซึ่งต้องการ Ouput เฉพาะของตัวเอง  (`plotlyOutput`)

## `ggplotly` ในฝั่งของ server

-   Plotly มีระบบการplotหรือสร้างกราฟต่างๆของตัวเองที่ดีมาก [`plot_ly()`](https://rdrr.io/cran/plotly/man/plot_ly.html)
-   ซึ่งก็เป็นโชคของเราที่เราเพียงเรียกใช้ [`ggplotly()`](https://rdrr.io/cran/plotly/man/ggplotly.html) กับตัวกราฟที่สร้างจาก ggplot มันก็จะถูกเปลี่ยนเป็นไปใช้ plotly แทน

```{r eval=F}
dat <- reactive({
	x <- input$model_x
	y <- input$model_y
	dt <- sf::st_drop_geometry(guerry)[c(x, y)]
	if (input$model_std) dt <- datawizard::standardise(dt)
	dt
}) %>%
	bindEvent(input$refresh, ignoreNULL = FALSE)

output$pairplot <- plotly::renderPlotly({                # <1>
	p <- GGally::ggpairs(dat(), axisLabels = "none")
	plotly::ggplotly(p)                                    # <2>
})
```

1.  ตัวplot จาก Plotly ไม่ใช่แบบกราฟนิ่งๆแล้ว เราก็ต้องการสร้างกราฟเฉพาะคือ `plotly::renderPlotly()`
2.  ในขณะเดียวกันเราก็ต้องเปลี่ยนกราฟของเราจาก ggplot ให้เป็นแบบ plotly ด้วย `plotly::ggplotly()`

![](resources/05_03.gif)

## ขยายการใช้งาน Plotly

-   ตอนนี้เราสามารถเป็นกราฟจาก ggplot ให้เป็น plotly ได้ด้วยคำสั่งเดียว 
-   แต่หลายๆส่วนของ plot ก็ยังใช้ไม่ได้เพราะเราไม่ได้สร้างกราฟจากคำสั่ง `plot_ly()` โดยตรง

### การแก้ไขปรับแต่ง Plotly 

-   เราสามารถปรับแต่งกราฟจาก Plotly ได้โดยอาศัย 3 คำสั่งนี้:
    -   `layout()` สำหรับปรับเปลี่ยนหน้าตาของกราฟ อย่างเช่น สี ฟ้อนท์ ขนาด ตำแหน่ง สัดส่วน และอื่นๆ (เช่นเดียวกันกับ [`ggplot2::theme()`](https://ggplot2.tidyverse.org/reference/theme.html))
        -   `updatemenus` ใส่ปุ่มหรือเมนูสำหรับเปลี่ยน layout ( [ดูที่นี่](https://plotly.com/r/dropdowns/) สำหรับตัวอย่าง)
        -   `sliders` ใส่ sliders ([ดูที่นี่](https://plotly.com/r/sliders/) สำหรับตัวอย่าง)
    -   `config()` เปลี่ยนการตั้งค่าการโต้ตอบ:
        -   `modeBarButtons` กับ `displaylogo` ควบคุมปุ่มใน mode bar
        -   `toImageButtonOptions` ควบคุมรูปแบบ downloads
        -   `scrollZoom` ควบคุมว่าให้มีการซูมด้วยการ scroll หรือไม่
    -   `style()` เปลี่ยนพวกสไตล์ (คล้ายๆกับ [`ggplot2::scale_`](https://ggะplot2.tidyverse.org/reference/#scales)) เช่น:
        -   `hoverinfo` ควบคุมว่าจะให้โชว์ tooptip หรือไม่เวลาวางลูกศรชี้ไว้
        -   `mode` ความคุมว่าจให้โชว์ จุด เส้น หรือ ข้อความใน scatter plot หรือไม่
        -   `hovertext` แก้ไขข้อความใน tooltips

### Schema ผังการปรับแต่ง

-   options มันเยอะมาก
-   ถ้าอยากดูทั้งหมด ลองพิมพ์เรียก [`plotly::schema()`](https://rdrr.io/cran/plotly/man/schema.html)

```{r eval=FALSE}
plotly::schema()
```

```{r echo=FALSE}
sch <- listviewer::jsonedit(plotly:::Schema, mode = "form")
path <- file.path(getwd(), "schema.html")
htmlwidgets::saveWidget(sch, path)
tags$iframe(srcdoc = paste(readLines(path), collapse = '\n'), width = "100%", height = 500)
```

```{r echo=FALSE}
unlink(path)
```

### ตัวอย่าง

-   เราสามารถปรับเปลี่ยนในส่วน mode bar กับ การ download ได้

```{r eval=FALSE}
ggplotly(p) %>%
  config(
  	modeBarButtonsToRemove = c(                                          # <1>
	  	"sendDataToCloud", "zoom2d", "select2d", "lasso2d", "autoScale2d", # <1>
			"hoverClosestCartesian", "hoverCompareCartesian", "resetScale2d"   # <1>
		),                                                                   # <1>
    displaylogo = FALSE,                                                 # <2>
		toImageButtonOptions = list(                                         # <3>
			format = "svg",                                                    # <3>
			filename = "guerry_plot",                                          # <3>
			height = NULL,                                                     # <3>
			width = NULL                                                       # <3>
		),                                                                   # <3>
		scrollZoom = TRUE                                                    # <4>
	)
```

1.  เลือกเอาปุ่มออกจาก modebar
2.  เอา logo ออก
3.  เซ็ตค่า `height` กับ `width` เป็น `NULL` เพื่อที่จะให้สัดส่นของกราฟหรือภาพเป็นตามที่โชว์ในapp
4.  ให้ใช้ zooming ได้

![](resources/05_03_config.png)

## Full ตัวเต็ม

```{r eval=FALSE, file="shinyapps/guerry/states/05_visualization03.R"}
#| code-fold: true
#| code-summary: Full code for interactive visualization
```

# Contextuality บริบท

-   ด้วยความเป็นบริบท (contextuality), เราเข้าใจโดยคร่าวว่าเรารับรู้แผนภูมิในบริบท
-	การแสดงแกราฟอย่างง่าย ๆ อาจเป็นสิ่งที่เพียงพอในการสื่อข้อความ
-	แต่ในหลาย ๆ กรณี, เราต้องการภาพรวมมากกว่าหนึ่งเพื่อนำเสนอเรื่องราวหรือเน้นเรื่อง
-	หลายครั้ง การมองภาพรวมอยู่ข้าง ๆ กันช่วยให้เราเข้าใจมากขึ้น
-	การพล็อตแบบปกติ: สามารถมีการโต้ตอบและตอบสนองได้ แต่ *ไม่มีความเป็นบริบท*
-	การพล็อตแบบฝัง: มีความเป็นบริบท แต่การโต้ตอบและตอบสนองนั้นเป็นไปได้ยาก (เช่น ในรายงานหรือบทความวิชาการ)

## แนวปฏิบัติที่ดี

-   [ตัวติดตามรังผึ้งของ US จาก Appsilon](https://connect.appsilon.com/bee-colony/) ให้ความสะดวกในการเปรียบเทียบตัวเลขที่รวมกัน ระหว่างรัฐและภายในรัฐด้วยกัน
-   ด้วยความคิดสร้างสรรค์เล็ก ๆ น้อย ๆ, Shiny สามารถเป็นผู้บรรยายเรื่องราวที่มีความสามารถอย่างมาก (สำหรับตัวอย่างที่น่าประทับใจ, ลองดูที่แอป Shiny ของ John Coene [Freedom of Press Shiny app](https://johncoene.shinyapps.io/fopi-contest/))

## การขยายรูปแบบการแสดงผล

-   เราจะขยายการแสดงผลที่เรามีอยู่ด้วยการวิเคราะห์การถดถอยเพื่ออธิบายเกี่ยวกับการเชื่อมโยงของตัวแปรตัวบ่งชี้ของ Guerry
-   เราเพิ่มสามแบบของการแสดงผลภาพ: แผนภูมิแสดงค่าสัมประสิทธิ์, แผนภูมิกระจาย และตารางการถดถอย
-   ทั้งสามแบบของการแสดงผลถูกใส่ไว้ใน [`tabBox`](https://rinterface.github.io/bs4Dash/reference/tabBox.html)   [`bs4Dash::box`](https://rinterface.github.io/bs4Dash/reference/box.html) ซึ่งรองรับ tab panels

```{r eval=F}
model <- tabItem(
	"tab_model",
	fluidRow(
		column(
			width = 6,
			#### Box: Select variables ----
      box(
				width = 12,
				title = "Select variables",
				status = "primary",
				selectInput(
					"model_x",
					label = "Select a dependent variable",
					choices = setNames(names(variable_names), variable_names),
					selected = "Literacy"
				),
				selectizeInput(
					"model_y",
					label = "Select independent variables",
					choices = setNames(names(variable_names), variable_names),
					multiple = TRUE,
					selected = "Commerce"
				),
				checkboxInput(
					"model_std",
					label = "Standardize variables?",
					value = TRUE
				),
				hr(),
				actionButton(
					"refresh",
					label = "Apply changes",
					icon = icon("refresh"),
					flat = TRUE
				)
			),
      #### Box: Coefficient/Scatterplot ----
			tabBox(                                      # <1>
			  status = "primary",                        # <1>
			  width = 12,                                # <1>
			  type = "tabs",                             # <2>
			  ##### Tab: Coefficient plot ----
			  tabPanel(                                  # <3>
			    title = "Plot: Coefficients",            # <3>
			    plotly::plotlyOutput("coefficientplot")  # <3>
			  ),                                         # <3>
			  ##### Tab: Scatterplot ----
			  tabPanel(                                  # <4>
			    title = "Plot: Scatterplot",             # <4>
			    plotly::plotlyOutput("scatterplot")      # <4>
			  ),                                         # <4>
			  ##### Tab: Table: Regression ----
			  tabPanel(                                  # <5>
			    title = "Table: Model",                  # <5>
			    htmlOutput("tableregression")            # <5>
			  )                                          # <5>
			)
		),
		#### Box: Pair diagramm ----
		column(
			width = 6,
	    box(
				width = 12,
				title = "Pair diagram",
				status = "primary",
				plotly::plotlyOutput("pairplot")
			)
		)
	)
)
```

1.  เพิ่ม `tabBox()` ใหม่ซึ่งสามารถรองรับ `tabPanel()` หลายๆแท็บ
2.  ระบุลักษณะการแสดงผลของแท็บ `pills` จะเติมสีให้กับทั้งหมดของแท็บแผงตามสถานะ ในขณะที่ `tabs` มีการเติมสีอย่างอ่อนโยนมากขึ้น 
3.  เพิ่มแท็บที่มีแผนภูมิแสดงค่าสัมประสิทธิ์จาก Plotly
4.  เพิ่มแท็บที่มีแผนภูมิกระจายจาก Plotly
5.  เพิ่มแท็บที่มีตารางการถดถอยแบบ HTML

## การทำความเข้าใจรูปแบบใหม่

-   **คำถาม:** เราได้เพิ่มอะไรบ้างในที่นี่ ผลลัพธ์ใดที่ต้องการเนื้อหาเพื่อแสดงผล
-   ที่ฝั่งของserver เราขยาย reactive object ด้วยโมเดลการถดถอยแบบเชิงเส้น

```{r eval=F}
mparams <- reactive({                                            # <1>
	x <- input$model_x
	y <- input$model_y
	dt <- sf::st_drop_geometry(guerry)[c(x, y)]
	if (input$model_std) dt <- datawizard::standardise(dt)
	form <- as.formula(paste(x, "~", paste(y, collapse = " + ")))  # <2>
	mod <- lm(form, data = dt)                                     # <2>

	list(x = x,	y = y, data = dt,	model = mod)                     # <3>
}) %>%
	bindEvent(input$refresh, ignoreNULL = FALSE)
```

1.	เราเปลี่ยนชื่อ `dat()` เป็น `mparams()` เนื่องจากตอนนี้มันเก็บอาร์กิวเมนต์หลายตัว แทนที่จะเป็น dataframe เดียว
2.	สร้างสูตรและสร้างผลลัพธ์จาก linear regression
3.	ส่งคืนlistของอาร์กิวเมนต์เพื่อใช้สำหรับoutput

## การสร้างผลลัพธ์ output

-   ากขั้นตอนนี้เราสามารถนำ`mparams`ซึ่งเป็น reactive object เข้าไปในฟังก์ชันการแสดงผลทั้งหมด 

```{r eval=F}
### Pair diagram ----
output$pairplot <- renderPlotly({                           # <1>
	p <- GGally::ggpairs(mparams()$data, axisLabels = "none") # <1>
	ggplotly(p)                                               # <1>
})                                                          # <1>

### Plot: Coefficientplot ----
output$coefficientplot <- renderPlotly({                    # <2>
	params <- mparams()                                       # <2>
	dt <- params$data                                         # <2>
	x <- params$x                                             # <2>
	y <- params$y                                             # <2>
                                                            # <2>
	p <- plot(parameters::model_parameters(params$model))     # <2>
                                                            # <2>
	ggplotly(p)                                               # <2>
})                                                          # <2>

### Plot: Scatterplot ----
output$scatterplot <- renderPlotly({                        # <3>
	params <- mparams()                                       # <3>
	dt <- params$data                                         # <3>
	dt_labels <- params$data_labels                           # <3>
	x <- params$x                                             # <3>
	y <- params$y                                             # <3>
                                                            # <3>
                                                            # <3>
	if (length(y) == 1) {                                     # <3>
	  p <- ggplot(params$data,                                # <3>
	              aes(x = .data[[params$x]],                  # <3>
	                  y = .data[[params$y]])) +               # <3>
	    geom_point() +                                        # <3>
	    geom_smooth() +                                       # <3>
	    theme_light()                                         # <3>
	} else {                                                  # <3>
	  p <- ggplot() +                                         # <3>
	    theme_void() +                                        # <3>
	    annotate("text",                                      # <3>
	             label = "Cannot create scatterplot.\nMore than two variables selected.", # <3>
	             x = 0, y = 0,                                # <3>
	             size = 5,                                    # <3>
	             colour = "red",                              # <3>
	             hjust = 0.5,                                 # <3>
	             vjust = 0.5) +                               # <3>
	  xlab(NULL)                                              # <3>
	                                                          # <3>
	}                                                         # <3>
                                                            # <3>
	ggplotly(p)                                               # <3>
})                                                          # <3>

### Table: Regression ----
output$tableregression <- renderUI({                        # <4>
	params <- mparams()                                       # <4>
	HTML(modelsummary(                                        # <4>
		dvnames(list(params$model)),                            # <4>
	  gof_omit = "AIC|BIC|Log|Adj|RMSE"                       # <4>
	))                                                        # <4>
})                                                          # <4>
```

1.	เราต้องเปลี่ยน input สำหรับ `ggpairs()` เนื่องจากชื่อและโครงสร้างของreactive objectมีการเปลี่ยนแปลง
2.	สร้างแผนภูมิแสดงค่าสัมประสิทธิ์ของ Plotly โดยใช้แพ็คเกจ `parameters`
3.	สร้างแผนภูมิกระจายของ Plotly สำหรับการถดถอยแบบสองตัวแปร หากเลือกตัวแปร y มากกว่าหนึ่งตัว จะสร้างแผนภูมิที่ว่างเปล่าและแสดงข้อความเตือน
4.	สร้างตารางของโมเดลโดยใช้แพ็คเกจ `modelsummary` และเตรียมสำหรับการแสดงผลแบบ HTML

![](resources/05_04.gif)

## code ตัวเต็ม

```{r eval=FALSE, file="shinyapps/guerry/states/05_visualization04.R"}
#| code-fold: true
#| code-summary: Full code for contextual visualization
```

# Exercises

::: callout-note
## แบบฝึกหัด 1

เมื่อคิดกลับไปยังโครงสร้างการแสดงผลเริ่มต้นของเรา (การเลือกข้อมูล, การสำรวจข้อมูล, การสร้างโมเดลข้อมูล, และอื่นๆ) ขั้นตอนสุดท้ายที่ดีควรจะเป็นอย่างไร แบบของการแสดงผลใดที่ช่วยให้เข้าใจเกี่ยวกับความสัมพันธ์ของตัวแปร Guerry โปรดเขียนความคิดเห็นของคุณพร้อมกับประเภทของการแสดงผลที่เป็นไปได้
:::

::: {.callout-tip collapse="true"}
ดู [R graph gallery](https://r-graph-gallery.com/) หรือ [R Plotly gallery](https://plotly.com/r/) 
:::

::: callout-note
## แบบฝึกหัด 2

เพิ่มช่องที่สี่ในรูปแบบ dashboard และเพิ่มกล่องที่จะรองรับเนื้อหาด้วย.
:::

::: {.callout-tip collapse="true"}
อย่าลืมเกี่ยวกับการใช้ fluidRow() และ column() ช่องใหม่นี้จะต้องอยู่ด้านล่างของแผนภูมิคู่ในคอลัมน์ที่สอง:

```{r eval=FALSE}
fluidRow(
	column(
		width = 6,
		box(width = 12), # quadrant 1
		box(width = 12) # quadrant 3
	),
	column(
		width = 6,
		box(width = 12), # quadrant 2
		box(width = 12) # quadrant 4
	)
)
```
:::

::: {.callout-warning collapse="true"}
## คำตอบ

ช่องที่สี่คือแถวที่สองของคอลัมน์ที่สอง นั่นคือ:
```{r eval=FALSE}
fluidRow(
	column(
		width = 6,
		box(width = 12), # quadrant 1
		box(width = 12) # quadrant 3
	),
	column(
		width = 6,
		box(width = 12), # quadrant 2
		box(width = 12, status = "primary", plotOutput("new_plot")) # quadrant 4
	)
)
```
:::

::: callout-note
## แบบฝึกหัด 3

เพิ่ม UI สำหรับแสดงผลและฟังก์ชันการแสดงผลที่ว่างเปล่า
:::

::: {.callout-tip collapse="true"}

ฟังก์ชันของ Plotly ที่เกี่ยวข้องคือ`plotly::plotlyOutput()` and `plotly::renderPlotly()`
:::

::: callout-note
## แบบฝึกหัด 4

นำเสนอการแสดงผลจากแบบฝึกหัดที่ 1 ภายในกล่องใหม่จากแบบฝึกหัดที่ 2 สร้างแผนภูมิของคุณโดยใช้ ggplot2 และแปลงมันเป็นแผนภูมิ plotly โดยใช้ `ggplotly()`
:::

::: callout-note
## แบแฝึกหัด 5

ลบปุ่มทั้งหมดในแถบโหมดยกเว้น "Zoom in" และ "Zoom out" ออกจากการแสดงผลใหม่ในแบบฝึกหัดที่ 4
:::

::: {.callout-tip collapse="true"}
คำสั่งที่เกี่ยวข้อง `plotly::config()`

A list of modebar buttons is provided on Plotly's [GitHub repository](https://github.com/plotly/plotly.js/blob/master/src/components/modebar/buttons.js) or under `object -> layout -> layoutAttributes -> modebar -> remove`

เรียกใช้ `schema()` และสำรวจใน `object -> config` เพื่อหาวิธีการลบปุ่มบนแถบโหมด

รายการของปุ่ม modebar มีให้ดูที่ GitHub repository ของ Plotly หรือภายใต้ `object -> layout -> layoutAttributes -> modebar -> remove`
:::

::: {.callout-warning collapse="true"}
## Solution

เพื่อลบปุ่มบนแถบโหมด, เราต้องเปลี่ยน `plotly::config()` ของผลลัพธ์การแสดงผลที่ได้จากการสร้างแผนภูมิ:

```{r eval=FALSE}
ggplotly(p) %>%
  config(modeBarButtonsToRemove = c(
    "sendDataToCloud", "zoom2d", "select2d", "lasso2d", "autoScale2d", "toimage",
    "hoverClosestCartesian", "hoverCompareCartesian", "resetScale2d", "pan"
))
```
:::

::: callout-note
## แบบฝึกหัด 6

เปลี่ยนความกว้างของแกนของแผนภูมิใหม่จากแบบฝึกหัดที่ 4 เป็น 5 พิกเซลและเปลี่ยนสีเป็น #000
:::

::: {.callout-note collapse="true"}
ฟังก์ชันที่เกี่ยวข้องคือ `plotly::layout()`

เรียกใช้ `schema()` และสำรวจใน `object -> layout -> layoutAttributes` เพื่อหาวิธีการเปลี่ยนแปลงการวางแกน
:::

::: {.callout-warning collapse="true"}
## Solution

เพื่อเปลี่ยนความกว้างของแกน เราต้องเปลี่ยน `plotly::layout()`  การกำหนดว่าตัวเลือกไหนควบคุมการวางแกนเป็นคำถามที่ยาก เพื่อทำเช่นนั้น, เราสามารถสำรวจ `plotly::schema()` ในกรณีนี้  ตัวเลือกที่เกี่ยวข้องจะพบได้ภายใต้ `object -> layout -> layoutAttributes -> xaxis/yaxis -> linewidth/linecolor` หลังจากนั้น, เพียงเพิ่ม layout ในวัตถุ plot และเปลี่ยนตัวเลือกที่เกี่ยวข้อง:

```{r eval=FALSE}
ggplotly(p) %>%
	layout(
	  xaxis = list(linewidth = 5, linecolor = "#000"),
	  yaxis = list(linewidth = 5, linecolor = "#000")
	)
```
:::

::: callout-note
## แบบฝึกหัด 7

ตอนนี้รามีตัวinputsสามตัวที่มีผลกับการเปลี่ยนแปลงการแสดงผล: `model_x`  `model_y` และ `model_std` การเพิ่มinputอีกตัวหนึ่งเพื่อให้ผู้ใช้สามารถจัดการข้อมูล ผลลัพธ์ หรือการแสดงผลของแผนภูมิได้
:::

::: {.callout-tip collapse="true"}
inputs ใหม่ควรจะเปลี่ยนแปลงแผนภูมิทั้งหมดหรือเพียงบางส่วนของแผนภูมิ ตัวinputใหม่ควรจะควบคุมวิธีที่ข้อมูลถูกclean (เช่น การทำnormalise) หรือวิเคราะห์ (เช่น วิธีการสร้างแบบจำลองที่แตกต่างกัน) หรือการแสดงผล (เช่น ธีมการแสดงผลแผนภูมิ) หรือไม่
:::
